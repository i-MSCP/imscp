#!/usr/bin/perl

# ispCP ω (OMEGA) a Virtual Hosting Control Panel
# Copyright (C) 2001-2006 by moleSoftware GmbH - http://www.molesoftware.com
# Copyright (C) 2006-2009 by isp Control Panel - http://ispcp.net
#
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is "VHCS - Virtual Hosting Control System".
#
# The Initial Developer of the Original Code is moleSoftware GmbH.
# Portions created by Initial Developer are Copyright (C) 2001-2006
# by moleSoftware GmbH. All Rights Reserved.
# Portions created by the ispCP Team are Copyright (C) 2006-2009 by
# isp Control Panel. All Rights Reserved.
#
# The ispCP ω Home Page is:
#
#    http://isp-control.net
#

use FindBin;
use lib "$FindBin::Bin/";
require 'ispcp_common_code.pl';

use strict;

use warnings;

$main::mail_task_id = undef;
$main::sub_id_name = undef;
$main::alssub_id_name = undef;
$main::alssub_id_parentid =undef;

sub mbox_get_dmn_full_name{

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_get_dmn_full_name()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {
		push_el(\@main::el, 'mbox_get_dmn_full_name()', 'ERROR: Undefined Input Data...');
		return (-1,'');
	}

	my $dmn_full =undef;

	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];

	if ($mail_type =~ /^normal_*/){

		$dmn_full = $main::domain_id_name{$mail_dmn_id};
		push_el(\@main::el, 'mbox_get_dmn_full_name()', "dbg: dmn_name: $dmn_full");

	} elsif ($mail_type =~ /^alias_*/) {

		$dmn_full = $main::als_id_name{$mail_sub_id};
		push_el(\@main::el, 'mbox_get_dmn_full_name()', "dbg: als_name: $dmn_full");

	} elsif ($mail_type =~ /^subdom_*/) {

		my $sub_pref = $main::sub_id_name{$mail_sub_id};
		my $dmn_name = $main::domain_id_name{$mail_dmn_id};

		$dmn_full = "$sub_pref.$dmn_name";
		push_el(\@main::el, 'mbox_get_dmn_full_name()', "dbg: sub_pref: $sub_pref, dmn_name: $dmn_name, sub_name: $dmn_full");

	} elsif ($mail_type =~ /^alssub_*/) {

		my $sub_pref = $main::alssub_id_name{$mail_sub_id};
		my $dmn_name = $main::als_id_name{$main::alssub_id_parentid{$mail_sub_id}};

		$dmn_full = "$sub_pref.$dmn_name";
		push_el(\@main::el, 'mbox_get_dmn_full_name()', "dbg: als_sub_pref: $sub_pref, als_name: $dmn_name, als_sub_name: $dmn_full");

	} else {

		push_el(\@main::el, 'mbox_get_dmn_full_name()', 'ERROR: Undefined mail type...');
		return (-1,'');

	}

	push_el(\@main::el, 'mbox_get_dmn_full_name()', 'Ending...');
	return (0,$dmn_full);
}

sub get_mta_hash_value {

	my ($hfile, $key) = @_;

	push_el(\@main::el, 'get_mta_hash_value()', 'Starting...');

	if (!defined($hfile) || $hfile eq '' || !defined($key) || $key eq '') {

		push_el(\@main::el, 'get_mta_hash_value()', 'ERROR: Undefined Input Data...');
		return (-1, '');

	}

	my ($rs, $rdata, $ekey) = (undef, undef, $key);
	$ekey =~ s/\./\\\./g; # escape the dots in $key

	($rs, $rdata) = get_file($hfile);
	return $rs if ($rs != 0);

	$rdata =~ /^$ekey\t+([^\n]+)\n/gim;
	$rdata = $1;

	if (!defined($rdata)) { $rdata = ''; }

	push_el(\@main::el, 'get_mta_hash_value()', 'Ending...');
	return (0, $rdata);

}

sub del_mta_hash_value {

	my ($hfile, $key) = @_;

	push_el(\@main::el, 'del_mta_hash_value()', 'Starting...');

	if (!defined($hfile) || $hfile eq '' || !defined($key) || $key eq '') {

		push_el(\@main::el, 'del_mta_hash_value()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $ekey) = (undef, undef, $key);
	$ekey =~ s/\./\\\./g; # escape the dots in $key

	($rs, $rdata) = get_mta_hash_value($hfile, $key);
	return 0 if ($rdata eq '');

	($rs, $rdata) = get_file($hfile);
	return $rs if ($rs != 0);

	$rdata =~ s/^$ekey\t+([^\n]+)\n//gim;

	$rs = store_file($hfile, $rdata, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'del_mta_hash_value()', 'Ending...');
	return 0;

}

sub set_mta_hash_value {

	my ($hfile, $key, $value) = @_;

	push_el(\@main::el, 'set_mta_hash_value()', 'Starting...');

	if (!defined($hfile) || $hfile eq '' || !defined($key) || $key eq '' || !defined($value) || $value eq '') {

		push_el(\@main::el, 'set_mta_hash_value()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $fdata, $ekey) = (undef, undef, undef, $key);
	$ekey =~ s/\./\\\./g; # escape the dots in $key

	($rs, $rdata) = get_mta_hash_value($hfile, $key);
	return $rs if ($rs != 0);

	($rs, $fdata) = get_file($hfile);
	return $rs if ($rs != 0);

	$fdata =~ s/^$ekey\t+([^\n]+)\n//gim if ($rdata ne '');
	$fdata .= "$key\t$value\n";

	$rs = store_file($hfile, $fdata, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'set_mta_hash_value()', 'Ending...');
	return 0;

}

sub mbox_mngr_start_up {

	my ($rs, $rdata) = (undef, undef);

	push_el(\@main::el, 'mbox_mngr_start_up()', 'Starting...');

	# checking for master process;

	$rs = check_master();
	return $rs if ($rs != 0);

	# Let's clear Execution Logs, if any.

	if (-e $main::ispcp_mbox_mngr_el) {

		$rs = del_file($main::ispcp_mbox_mngr_el);
		return $rs if ($rs != 0);

	}

	# config check;

	$rs = get_conf();
	return $rs if ($rs != 0);

	# sql check;

	#
	# getting initial data also must be done here;
	#

	my $sql = "
		SELECT
		mail_id,
		mail_acc,
		mail_pass,
		mail_forward,
		domain_id,
		mail_type,
		sub_id,
		status,
		mail_auto_respond,
		quota,
		mail_addr
	FROM
		mail_users
	";

	($rs, $rdata) = doSQL($sql);
	return $rs if ($rs != 0);

	$rs = get_domain_ids();
	return $rs if ($rs != 0);

	$rs = get_subdom_ids();
	return $rs if ($rs != 0);

	$rs = get_alssub_ids();
	return $rs if ($rs != 0);

	$rs = get_alias_ids();
	return $rs if ($rs != 0);

	$main::mail_task_id = $ARGV[0];

	push_el(\@main::el, 'mbox_mngr_start_up()', 'Ending...');
	return 0;

}

sub mbox_mngr_shut_down {

	my $rs = undef;

	push_el(\@main::el, 'mbox_mngr_shut_down()', 'Starting...');
	push_el(\@main::el, 'mbox_mngr_shut_down()', 'Ending...');
	return 0;

}

sub mbox_check_sasl_user {

	my ($uname) = @_;

	push_el(\@main::el, 'mbox_check_sasl_user()', 'Starting...');

	my ($rs, $rdata) = (undef, undef);
	my $check_file = "/tmp/ispcp-mbox-check-sasl-user";
	my $cmd = "$main::cfg{'CMD_SASLDB_LISTUSERS2'} -f $main::cfg{'MTA_SASLDB_FILE'} | $main::cfg{'CMD_GREP'} '$uname' &> $check_file";

	sys_command_rs($cmd);

	if (-z $check_file) {

		$rdata = 0;

	} else {

		$rdata = 1;
	}

	$rs = del_file($check_file);

	push_el(\@main::el, 'mbox_check_sasl_user()', 'Starting...');
	return (0, $rdata);

}

# Adds an new user into sasldb file
# Adds that user into the senders-access file
# Updates the btree file from the new sender-access file
sub mbox_add_sasl_data {

	push_el(\@main::el, 'mbox_add_sasl_data()', 'Starting...');

	my ($mbox_data) = @_;

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_add_sasl_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $cmd) = (undef, undef, undef);

	my ($dmn_name, $cmd_add_user, $cmd_del_user) = (undef,undef, undef);

	# Working data
	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_pass = @$mbox_data[2];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	# Diretories paths
	my $cfg_dir = "$main::cfg{'CONF_DIR'}/postfix";
	my $bkp_dir = "$cfg_dir/backup";
	my $wrk_dir = "$cfg_dir/working";

	# Files paths
	my $mta_sasldb_file = $main::cfg{'MTA_SASLDB_FILE'};
	my $etc_sasldb_file = $main::cfg{'ETC_SASLDB_FILE'};

	do {

		($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
		return $rs if ($rs != 0);

		$mail_pass=decrypt_db_password($mail_pass);

		$cmd_del_user = "$main::cfg{'CMD_SASLDB_PASSWD2'} -d -f $etc_sasldb_file -u $dmn_name $mail_acc";

		if($etc_sasldb_file ne $mta_sasldb_file) {
			$cmd_del_user .= " && $main::cfg{'CMD_CP'} -pf $etc_sasldb_file $mta_sasldb_file";
		}

		$cmd_add_user = "$main::cfg{'CMD_ECHO'} \"$mail_pass\" | $main::cfg{'CMD_SASLDB_PASSWD2'} -p -c -f $etc_sasldb_file -u $dmn_name $mail_acc";

		if($etc_sasldb_file ne $mta_sasldb_file) {
			$cmd_add_user .= " && $main::cfg{'CMD_CP'} -pf $etc_sasldb_file $mta_sasldb_file";
		}

		# Check if the user already exits in sasldb file
		($rs, $rdata) = mbox_check_sasl_user("$mail_acc\@$dmn_name");
		return $rs if ($rs != 0);

		# if the user already exit in sasldb file, remove it before.
		if ($rdata) {
			sys_command_rs($cmd_del_user);
		}

		# Adds the new user account in sasldb file
		$rs = sys_command($cmd_add_user);
		return $rs if ($rs != 0);

		# Sets the rights owner, group and permissions
		$rs = setfmode(
			$mta_sasldb_file,
			$main::cfg{'ROOT_USER'},
			$main::cfg{'ROOT_GROUP'},
			0644
		);
		return $rs if ($rs != 0);

		# Saving the current sender-access file if it exits
		if(-e $main::cfg{'MTA_SENDER_ACCESS_HASH'})
		{
			my $timestamp = time;

			$cmd = "$main::cfg{'CMD_CP'} -p $main::cfg{'MTA_SENDER_ACCESS_HASH'} $bkp_dir/sender-access.$timestamp";
			$rs = sys_command_rs($cmd);
			return $rs if($rs != 0);
		}

		# Building, store and installation of new sender-access file - Begin

		# Building and store the new file
		$rs = set_mta_hash_value("$wrk_dir/sender-access", "$mail_acc\@$dmn_name", 'OK');
		return $rs if ($rs != 0);

		# Install the new file in production directory
		$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/sender-access $main::cfg{'MTA_SENDER_ACCESS_HASH'}";
		$rs = sys_command_rs($cmd);
		return $rs if($rs != 0);

		# Building, store and installation of sender-access file - End

		# Update the related btree file from the new sender-access file
		$rs = sys_command("$main::cfg{'CMD_POSTMAP'} $main::cfg{'MTA_SENDER_ACCESS_HASH'}");
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(?:normal|alias|subdom|alssub)_mail.*/);

	push_el(\@main::el, 'mbox_add_sasl_data()', 'Ending...');

	0;
}

sub mbox_add_po_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_add_po_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_add_po_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata) = (undef, undef);
	my ($sys, $working) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_pass = @$mbox_data[2];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};
	my $mbox_uid = $main::cfg{'MTA_MAILBOX_UID'};
	my $mbox_gid = $main::cfg{'MTA_MAILBOX_GID'};
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $courier_dir = $main::cfg{'AUTHLIB_CONF_DIR'};
	my $cmd_makeuserdb = $main::cfg{'CMD_MAKEUSERDB'};

	my $working_dir = "$conf_dir/courier/working";
	my $backup_dir = "$conf_dir/courier/backup";
	my $timestamp = time;
	my $userdb_cfg = "$courier_dir/userdb";
	my $userdb_working_cfg = "$working_dir/userdb";
	my $userdb_backup_cfg = "$backup_dir/userdb.$timestamp";

	($rs, $sys) = get_file($userdb_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($userdb_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	my ($hash_key, $hash_value) = (undef, undef);

	do {

		$mail_pass=decrypt_db_password($mail_pass);

		my ($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
		return $rs if ($rs != 0);

		($rs, $rdata) = crypt_md5_data($mail_pass);
		return $rs if ($rs != 0);

		$hash_key = "$mail_acc\@$dmn_name";
		$hash_value = "uid=$mbox_uid|gid=$mbox_gid|home=$virtual_mail_dir/$dmn_name/$mail_acc|shell=/bin/false|systempw=$rdata|mail=$virtual_mail_dir/$dmn_name/$mail_acc";

		$rs = set_mta_hash_value($userdb_working_cfg, $hash_key, $hash_value);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(?:normal|alias|subdom|alssub)_mail.*/);

	($rs, $working) = get_file($userdb_working_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($userdb_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0600);
	return $rs if ($rs != 0);

	$rs = sys_command($cmd_makeuserdb);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_add_po_data()', 'Ending...');
	return 0;

}

sub mbox_add_mta_file_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_add_mta_file_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_add_mta_file_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};
	my $mailbox_uid_name = $main::cfg{'MTA_MAILBOX_UID_NAME'};
	my $mailbox_gid_name = $main::cfg{'MTA_MAILBOX_GID_NAME'};

	do {

		my ($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
		return $rs if ($rs != 0);

		my $dir_name = "$virtual_mail_dir/$dmn_name/$mail_acc";
		$rs = make_dir($dir_name, $mailbox_uid_name, $mailbox_gid_name, 0755);
		return $rs if ($rs != 0);

		$dir_name = "$virtual_mail_dir/$dmn_name/$mail_acc/cur";
		$rs = make_dir($dir_name, $mailbox_uid_name, $mailbox_gid_name, 0700);
		return $rs if ($rs != 0);

		$dir_name = "$virtual_mail_dir/$dmn_name/$mail_acc/tmp";
		$rs = make_dir($dir_name, $mailbox_uid_name, $mailbox_gid_name, 0700);
		return $rs if ($rs != 0);

		$dir_name = "$virtual_mail_dir/$dmn_name/$mail_acc/new";
		$rs = make_dir($dir_name, $mailbox_uid_name, $mailbox_gid_name, 0700);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(normal|alias|subdom|alssub)(_mail|_forward).*/);

	push_el(\@main::el, 'mbox_add_mta_file_data()', 'Ending...');
	return 0;

}

sub mbox_add_mta_cfg_autorespond_data {

	push_el(\@main::el, 'mbox_add_mta_cfg_autorespond_data()', 'Starting...');

	my ($mbox_data) = @_;

	if (!defined($mbox_data) || $mbox_data eq '') {
		push_el(\@main::el, 'mbox_add_mta_cfg_autorespond_data()', 'ERROR: Undefined Input Data...');
		return -1;
	}

	my ($rs, $rdata, $cmd) = (undef, undef,undef);

	my $working = undef;

	my ($hash_key, $hash_value, $dmn_name) = (undef, undef, undef);

	# Working data
	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $mail_forward_list = '';

	# Diretories paths
	my $cfg_dir = $main::cfg{'CONF_DIR'};
	my $bkp_dir = "$cfg_dir/postfix/backup";
	my $wrk_dir = "$cfg_dir/postfix/working";

	# Current time
	my $timestamp = time;

	# create a mail forward list

	if ($mail_forward ne '_no_') {
		$mail_forward_list = ',' . $mail_forward;
	}

	# Saving all current production files it they exist
	foreach($main::cfg{'MTA_VIRTUAL_ALIAS_HASH'}, $main::cfg{'MTA_TRANSPORT_HASH'})
	{
		next if(!-e $_);
		my ($fname) = /.*\/(.*)$/;

		$cmd = "$main::cfg{'CMD_CP'} -p $_ $bkp_dir/$fname.$timestamp";
		$rs = sys_command_rs($cmd);
		return $rs if($rs !=0);
	}

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		$hash_key = "$mail_acc\@$dmn_name";

		if ($mail_type =~ /.*_forward.*/)
		{
			$hash_value = undef;

			($rs, $rdata) = get_mta_hash_value("$wrk_dir/aliases", $hash_key);
			return $rs if ($rs != 0);

			if ($rdata eq '')
			{
				$hash_value = "$mail_acc\@$dmn_name,$mail_acc\@ispcp-arpl.$dmn_name";
			}
			else
			{
				$hash_value = $rdata.",$mail_acc\@ispcp-arpl.$dmn_name";
			}
		}
		else
		{
			$hash_value = "$mail_acc\@$dmn_name$mail_forward_list,$mail_acc\@ispcp-arpl.$dmn_name";

			$rs = del_mta_hash_value("$wrk_dir/aliases", $hash_key);
			return $rs if ($rs != 0);
		}

		# Building, store and installation of aliases file - Begin

		# Building and store the new file
		$rs = set_mta_hash_value("$wrk_dir/aliases", $hash_key, $hash_value);
		return $rs if ($rs != 0);

		# Install the new file in production directory
		$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/aliases $main::cfg{'MTA_VIRTUAL_ALIAS_HASH'}";
		$rs = sys_command_rs($cmd);
		return $rs if($rs != 0);

		# Building, store and installation of aliases file - End

		$hash_key = "ispcp-arpl.$dmn_name";
		$hash_value = "ispcp-arpl:";

		# Building, store and installation of transport file - Begin

		# Building and storage of the new file
		$rs = set_mta_hash_value("$wrk_dir/transport", $hash_key, $hash_value);
		return $rs if ($rs != 0);

		# Install the new file in production directory
		$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/transport $main::cfg{'MTA_TRANSPORT_HASH'}";
		$rs = sys_command_rs($cmd);
		return $rs if($rs != 0);

		# Building, store and installation of transport file - End

	} if ($mail_type =~ /.*(?:normal|alias|subdom|alssub)(_mail|_forward).*/);

	$rs = sys_command("$main::cfg{'CMD_POSTMAP'} $main::cfg{'MTA_TRANSPORT_HASH'}");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_add_mta_cfg_autorespond_data()', 'Ending...');

	0;
}

sub mbox_del_last_transport_entry {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_del_last_transport_entry()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_last_transport_entry()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $dmn_name) = (undef, undef, undef);

	my $mail_dmn_id = @$mbox_data[4];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_type = @$mbox_data[5];

	my $conf_dir = $main::cfg{'CONF_DIR'};

	my $working_dir = "$conf_dir/postfix/working";
	my $transport_working_cfg = "$working_dir/transport";

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	my $hash_key = "ispcp-arpl.$dmn_name";

	$rs = del_mta_hash_value($transport_working_cfg, $hash_key);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_del_last_transport_entry()', 'Ending...');

	return 0;

}

sub mbox_check_last_transport_entry {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_check_last_transport_entry()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_check_last_transport_entry()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rows, $sql) = (undef, undef, undef);

	my $mail_dmn_id = @$mbox_data[4];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_type = @$mbox_data[5];

	if ($mail_type =~ /^(alias_).*/) {

		$sql = "
			select count(mail_id) as cnt
			from mail_users
			where (status = 'ok' or status = 'change')
			and mail_auto_respond != '_no_'
			and domain_id = $mail_dmn_id
			and sub_id = $mail_sub_id
			and mail_type like 'alias_%';
		";

	} elsif ($mail_type =~ /^(subdom_).*/) {

		$sql = "
			select count(mail_id) as cnt
			from mail_users
			where (status = 'ok' or status = 'change')
			and mail_auto_respond != '_no_'
			and domain_id = $mail_dmn_id
			and sub_id = $mail_sub_id
			and mail_type like 'subdom_%';
		";

	}  elsif ($mail_type =~ /^(alssub_).*/) {

		$sql = "
			select count(mail_id) as cnt
			from mail_users
			where (status = 'ok' or status = 'change')
			and mail_auto_respond != '_no_'
			and domain_id = $mail_dmn_id
			and sub_id = $mail_sub_id
			and mail_type like 'alssub_%';
		";

	} else {

		$sql = "
			select count(mail_id) as cnt
			from mail_users
			where (status = 'ok' or status = 'change')
			and mail_auto_respond != '_no_'
			and domain_id = $mail_dmn_id
			and sub_id = 0
			and mail_type != 'normal_catchall'
			and mail_type != 'alias_catchall';
		";

	}

#print "\n\n\$sql:$sql\n\n";
	($rs, $rows) = doSQL($sql);
	return $rs if ($rs != 0);

	$rs = @$rows[0];

	push_el(\@main::el, 'mbox_check_last_transport_entry()', 'Ending...');

	return @$rs[0];
}

sub mbox_del_mta_cfg_autorespond_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_del_mta_cfg_autorespond_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_mta_cfg_autorespond_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata) = (undef, undef);
	my ($hash_key, $hash_value, $dmn_name) = (undef, undef, undef);
	my ($sys, $working) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $cmd_postmap = $main::cfg{'CMD_POSTMAP'};
	my $aliases_cfg = $main::cfg{'MTA_VIRTUAL_ALIAS_HASH'};
	my $transport_cfg = $main::cfg{'MTA_TRANSPORT_HASH'};

	my $timestamp = time;
	my $working_dir = "$conf_dir/postfix/working";
	my $backup_dir = "$conf_dir/postfix/backup";
	my $aliases_working_cfg = "$working_dir/aliases";
	my $aliases_backup_cfg = "$backup_dir/aliases.$timestamp";
	my $transport_working_cfg = "$working_dir/transport";
	my $transport_backup_cfg = "$backup_dir/transport.$timestamp";

	($rs, $sys) = get_file($aliases_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($aliases_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $sys) = get_file($transport_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($transport_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		$hash_key = "$mail_acc\@$dmn_name";

		($rs, $rdata) = get_mta_hash_value($aliases_working_cfg, $hash_key);
		return $rs if ($rs != 0);

		if ($rdata ne '') {

			$rdata =~ s/\,$mail_acc\@ispcp-arpl\.$dmn_name//gi;

			$rs = set_mta_hash_value($aliases_working_cfg, $hash_key, $rdata);
			return $rs if ($rs != 0);

		}

		($rs, $working) = get_file($aliases_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($aliases_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

		$rs = mbox_check_last_transport_entry($mbox_data);

		if ($rs == 0) {

			$rs = mbox_del_last_transport_entry($mbox_data);
			return $rs if ($rs != 0);

		} elsif ($rs == -1) {

			return $rs;

		}

		($rs, $working) = get_file($transport_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($transport_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(?:normal|alias|subdom|alssub)(_mail|_forward).*/);

	$rs = sys_command("$cmd_postmap $transport_cfg");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_del_mta_cfg_autorespond_data()', 'Ending...');
	return 0;

}

sub mbox_add_mta_cfg_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_add_mta_cfg_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_add_mta_cfg_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $dmn_name) = (undef, undef, undef);
	my ($sys, $working) = (undef, undef);
	my ($hash_key, $hash_value) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $cmd_postmap = $main::cfg{'CMD_POSTMAP'};
	my $aliases_cfg = $main::cfg{'MTA_VIRTUAL_ALIAS_HASH'};
	my $mailboxes_cfg = $main::cfg{'MTA_VIRTUAL_MAILBOX_HASH'};

	my $timestamp = time;
	my $tpl_dir = "$conf_dir/postfix/parts";
	my $working_dir = "$conf_dir/postfix/working";
	my $backup_dir = "$conf_dir/postfix/backup";
	my $mailboxes_working_cfg = "$working_dir/mailboxes";
	my $mailboxes_backup_cfg = "$backup_dir/mailboxes.$timestamp";
	my $aliases_working_cfg = "$working_dir/aliases";
	my $aliases_backup_cfg = "$backup_dir/aliases.$timestamp";

	($rs, $sys) = get_file($mailboxes_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($mailboxes_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $sys) = get_file($aliases_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($aliases_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		$hash_key = "$mail_acc\@$dmn_name";
		$hash_value = "$dmn_name/$mail_acc/";

		$rs = set_mta_hash_value($mailboxes_working_cfg, $hash_key, $hash_value);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($mailboxes_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($mailboxes_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

		if ($mail_type =~ /.*_mail.*/){
			if($mail_type =~ /.*forward.*/){
				$hash_value = $hash_key . ',' . $mail_forward;
			} else {
				$hash_value = $hash_key;
			}
		} else {
			$hash_value = $mail_forward;
		}

		$rs = set_mta_hash_value($aliases_working_cfg, $hash_key, $hash_value);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($aliases_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($aliases_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

		if ($mail_autorespond != 0) {
			$rs = mbox_add_mta_cfg_autorespond_data($mbox_data);
			return $rs if ($rs != 0);
		} else {
			$rs = mbox_del_mta_cfg_autorespond_data($mbox_data);
			return $rs if ($rs != 0);
		}

	} if ($mail_type =~ /^(normal|alias|subdom|alssub)(_mail|_forward).*/);

	do {

		my $hash_key = "\@$dmn_name";
		my $hash_value = undef;

		# Let's first remove old catchall accounts (if any);
		$rs = del_mta_hash_value($aliases_working_cfg, $hash_key);
		return $rs if ($rs != 0);

		$rdata = "$mail_acc\n";
		$rdata =~ /^([^\@]+)\@([^\n]+)\n$/i;

		my ($catch_all_usr, $catch_all_dmn) = ($1, $2);

		$hash_key = "\@$dmn_name";
		$hash_value = "$mail_acc";

		$rs = set_mta_hash_value($aliases_working_cfg, $hash_key, $hash_value);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($aliases_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($aliases_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /.*(normal|alias|subdom|alssub)_catchall.*/);

	$rs = sys_command("$cmd_postmap $mailboxes_cfg");
	return $rs if ($rs != 0);

	$rs = sys_command("$cmd_postmap $aliases_cfg");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_add_mta_cfg_data()', 'Ending...');
	return 0;

}

sub mbox_change_data {

	my ($mbox_data) = @_;

	my $rs = undef;

	push_el(\@main::el, 'mbox_change_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_change_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	$rs = mbox_add_data($mbox_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_change_data()', 'Ending...');
	return 0;

}

sub mbox_disable_data {

	my ($mbox_data) = @_;

	my $rs = undef;

	push_el(\@main::el, 'mbox_disable_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_disable_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	#
	# Remove all entries from the several config files
	#  but do not delete any file
	#

	$rs = mbox_del_mta_cfg_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_del_po_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_del_sasl_data($mbox_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_disable_data()', 'Ending...');
	return 0;

}

# Delete an user in sasldb file
# Delete the related data in sender-acccess file
# Updates the btree file from new senders-access file
sub mbox_del_sasl_data {

	push_el(\@main::el, 'mbox_del_sasl_data()', 'Starting...');

	my ($mbox_data) = @_;

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_sasl_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $cmd, $dmn_name) = (undef, undef, undef, undef);
	my $cmd_del_user =  undef;

	# Working data
	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_pass = @$mbox_data[2];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	# Directories paths
	my $cfg_dir = "$main::cfg{'CONF_DIR'}/postfix";
	my $bkp_dir = "$cfg_dir/backup";
	my $wrk_dir = "$cfg_dir/working";

	# Files paths
	my $mta_sasldb_file = $main::cfg{'MTA_SASLDB_FILE'};
	my $etc_sasldb_file = $main::cfg{'ETC_SASLDB_FILE'};

	do {

		($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
		return $rs if ($rs != 0);

		($rs, $rdata) = mbox_check_sasl_user("$mail_acc\@$dmn_name");
		return $rs if ($rs != 0);

		# Prepare cmd for deletion
		$cmd_del_user = "$main::cfg{'CMD_SASLDB_PASSWD2'} -d -f $etc_sasldb_file -u $dmn_name $mail_acc";

		if($etc_sasldb_file ne $mta_sasldb_file) {
			$cmd_del_user .= " && $main::cfg{'CMD_CP'} $etc_sasldb_file $mta_sasldb_file";
		}

		# Remove the user in the sasldb file
		if ($rdata) {
			sys_command_rs($cmd_del_user);
		}

		# Sets rights owner, group and permissions
		$rs = setfmode(
			$mta_sasldb_file,
			$main::cfg{'ROOT_USER'},
			$main::cfg{'ROOT_GROUP'},
			0644
		);
		return $rs if ($rs != 0);

		# Saving the current sender-access file if it exits
		if(-e $main::cfg{'MTA_SENDER_ACCESS_HASH'})
		{
			my $timestamp = time;

			$cmd = "$main::cfg{'CMD_CP'} -p $main::cfg{'MTA_SENDER_ACCESS_HASH'} $bkp_dir/sender-access.$timestamp";
			$rs = sys_command_rs($cmd);
			return $rs if($rs != 0);
		}

		# Building, store and installation of new sender-access file - Begin

		# Remove the user entries in the senders-access file and store it
		$rs = del_mta_hash_value("$wrk_dir/sender-access", "$mail_acc\@$dmn_name", 'OK');
		return $rs if ($rs != 0);

		# Install the new file in production directory
		$cmd = "$main::cfg{'CMD_CP'} -pf $wrk_dir/sender-access $main::cfg{'MTA_SENDER_ACCESS_HASH'}";
		$rs = sys_command_rs($cmd);
		return $rs if($rs != 0);

		# Building, store and installation of new sender-access file - End

		# Update the related btree file from the new sender-access file
		$rs = sys_command("$main::cfg{'CMD_POSTMAP'} $main::cfg{'MTA_SENDER_ACCESS_HASH'}");
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(?:normal|alias|subdom|alssub)_mail.*/);

	push_el(\@main::el, 'mbox_del_sasl_data()', 'Ending...');

	0;
}

sub mbox_del_po_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_del_po_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_po_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $dmn_name) = (undef, undef, undef);
	my ($sys, $working) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_pass = @$mbox_data[2];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};
	my $mbox_uid = $main::cfg{'MTA_MAILBOX_UID'};
	my $mbox_gid = $main::cfg{'MTA_MAILBOX_GID'};
	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $courier_dir = $main::cfg{'AUTHLIB_CONF_DIR'};
	my $cmd_makeuserdb = $main::cfg{'CMD_MAKEUSERDB'};

	my $timestamp = time;
	my $working_dir = "$conf_dir/courier/working";
	my $backup_dir = "$conf_dir/courier/backup";
	my $userdb_cfg = "$courier_dir/userdb";
	my $userdb_working_cfg = "$working_dir/userdb";
	my $userdb_backup_cfg = "$backup_dir/userdb.$timestamp";

	($rs, $sys) = get_file($userdb_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($userdb_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	my $hash_key = undef;

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		$hash_key = "$mail_acc\@$dmn_name";

		$rs = del_mta_hash_value($userdb_working_cfg, $hash_key);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /^(normal|alias|subdom|alssub)_mail.*/);

	($rs, $working) = get_file($userdb_working_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($userdb_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0600);
	return $rs if ($rs != 0);

	$rs = sys_command($cmd_makeuserdb);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_del_po_data()', 'Ending...');
	return 0;

}

sub mbox_del_mta_file_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_del_mta_file_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_mta_file_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $dmn_name) = (undef, undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $virtual_mail_dir = $main::cfg{'MTA_VIRTUAL_MAIL_DIR'};
	my $mailbox_uid_name = $main::cfg{'MTA_MAILBOX_UID_NAME'};
	my $mailbox_gid_name = $main::cfg{'MTA_MAILBOX_GID_NAME'};

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		my $dir_name = "$virtual_mail_dir/$dmn_name/$mail_acc";

		$rs = del_dir($dir_name);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /.*normal_mail.*/ || $mail_type =~/.*normal_forward.*/);

	push_el(\@main::el, 'mbox_del_mta_file_data()', 'Ending...');
	return 0;

}

sub mbox_del_mta_cfg_data {

	my ($mbox_data) = @_;

	push_el(\@main::el, 'mbox_del_mta_cfg_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_mta_cfg_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	my ($rs, $rdata, $dmn_name) = (undef, undef, undef);
	my ($hash_key, $hash_value) = (undef, undef);
	my ($sys, $working) = (undef, undef);

	my $mail_id = @$mbox_data[0];
	my $mail_acc = @$mbox_data[1];
	my $mail_forward = @$mbox_data[3];
	my $mail_dmn_id = @$mbox_data[4];
	my $mail_type = @$mbox_data[5];
	my $mail_sub_id = @$mbox_data[6];
	my $mail_autorespond = @$mbox_data[8];

	my $conf_dir = $main::cfg{'CONF_DIR'};
	my $cmd_postmap = $main::cfg{'CMD_POSTMAP'};
	my $mailboxes_cfg = $main::cfg{'MTA_VIRTUAL_MAILBOX_HASH'};
	my $aliases_cfg = $main::cfg{'MTA_VIRTUAL_ALIAS_HASH'};

	my $timestamp = time;
	my $tpl_dir = "$conf_dir/postfix/parts";
	my $working_dir = "$conf_dir/postfix/working";
	my $backup_dir = "$conf_dir/postfix/backup";
	my $mailboxes_working_cfg = "$working_dir/mailboxes";
	my $mailboxes_backup_cfg = "$backup_dir/mailboxes.$timestamp";
	my $aliases_working_cfg = "$working_dir/aliases";
	my $aliases_backup_cfg = "$backup_dir/aliases.$timestamp";

	($rs, $sys) = get_file($mailboxes_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($mailboxes_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $sys) = get_file($aliases_cfg);
	return $rs if ($rs != 0);

	$rs = store_file($aliases_backup_cfg, $sys, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
	return $rs if ($rs != 0);

	($rs, $dmn_name) = mbox_get_dmn_full_name($mbox_data);
	return $rs if ($rs != 0);

	do {

		$hash_key = "$mail_acc\@$dmn_name";

		$rs = del_mta_hash_value($mailboxes_working_cfg, $hash_key);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($mailboxes_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($mailboxes_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

		$rs = del_mta_hash_value($aliases_working_cfg, $hash_key);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($aliases_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($aliases_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

		if ($mail_autorespond != 0) {

			$rs = mbox_del_mta_cfg_autorespond_data($mbox_data);

			return $rs if ($rs != 0);

		}

	} if ($mail_type =~ /^(normal|alias|subdom|alssub)(_mail|_forward).*/);

	do {

		$hash_key = "\@$dmn_name";
		$hash_value = undef;

		$rs = del_mta_hash_value($aliases_working_cfg, $hash_key);
		return $rs if ($rs != 0);

		($rs, $working) = get_file($aliases_working_cfg);
		return $rs if ($rs != 0);

		$rs = store_file($aliases_cfg, $working, $main::cfg{'ROOT_USER'}, $main::cfg{'ROOT_GROUP'}, 0644);
		return $rs if ($rs != 0);

	} if ($mail_type =~ /.*(normal|alias|subdom|alssub)_catchall.*/);

	$rs = sys_command("$cmd_postmap $mailboxes_cfg");
	return $rs if ($rs != 0);

	$rs = sys_command("$cmd_postmap $aliases_cfg");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_del_mta_cfg_data()', 'Ending...');
	return 0;

}

sub mbox_del_data {

	my ($mbox_data) = @_;

	my $rs = undef;

	push_el(\@main::el, 'mbox_del_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_del_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	$rs = mbox_del_mta_cfg_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_del_mta_file_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_del_po_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_del_sasl_data($mbox_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_del_data()', 'Ending...');
	return 0;

}

sub mbox_add_data {

	my ($mbox_data) = @_;
	my $rs = undef;

	push_el(\@main::el, 'mbox_add_data()', 'Starting...');

	if (!defined($mbox_data) || $mbox_data eq '') {

		push_el(\@main::el, 'mbox_add_data()', 'ERROR: Undefined Input Data...');
		return -1;

	}

	$rs = mbox_add_mta_cfg_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_add_mta_file_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_add_po_data($mbox_data);
	return $rs if ($rs != 0);

	$rs = mbox_add_sasl_data($mbox_data);
	return $rs if ($rs != 0);

	push_el(\@main::el, 'mbox_add_data()', 'Ending...');
	return 0;

}

sub mbox_mngr_engine {

	push_el(\@main::el, 'mbox_mngr_engine()', 'Starting...');


	my ($rs, $rows, $rdata) = (undef, undef, undef);
	my ($timestamp, $sub_name, $msg) = (undef, undef, undef);
	my $sql = "
		SELECT
			mail_id, mail_acc, mail_pass,
			mail_forward, domain_id, mail_type,
			sub_id, status, mail_auto_respond, quota,
			mail_addr	FROM mail_users
		WHERE
			mail_id = $main::mail_task_id
	";

	($rs, $rows) = doSQL($sql);
	return $rs if ($rs != 0);

	my $entry = @$rows[0];
	my ($mbox_status, $mbox_id) = (@$entry[7], @$entry[0]);

	if ($mbox_status eq 'toadd') {

		$rs = mbox_add_data($entry);

		$timestamp = time();

		if ($rs == 0) {

			$sql = "update mail_users set status='ok' where mail_id = $mbox_id;";

		} else {

			my ($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));

			$msg =~ s/\'/\\\'/g;

			$sql = "update mail_users set status='$sub_name | $msg' where mail_id = $mbox_id;";

		}

		($rs, $rdata) = doSQL($sql);
		return $rs if ($rs != 0);

	} elsif ($mbox_status eq 'change' || $mbox_status eq 'toenable') {

		$rs = mbox_change_data($entry);

		$timestamp = time();

		if ($rs == 0) {

			$sql = "update mail_users set status='ok' where mail_id = $mbox_id;";

		} else {

			my ($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));

			$msg =~ s/\'/\\\'/g;

			$sql = "update mail_users set status='$sub_name | $msg' where mail_id = $mbox_id;";

		}

		($rs, $rdata) = doSQL($sql);
		return $rs if ($rs != 0);

	} elsif ($mbox_status eq 'delete') {

		$rs = mbox_del_data($entry);

		$timestamp = time();

		if ($rs == 0) {

			$sql = "delete from mail_users where mail_id = $mbox_id;";

		} else {

			my ($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));

			$msg =~ s/\'/\\\'/g;

			$sql = "update mail_users set status='$sub_name | $msg' where mail_id = $mbox_id;";

		}

		($rs, $rdata) = doSQL($sql);
		return $rs if ($rs != 0);

	} elsif ($mbox_status eq 'todisable') {

		$rs = mbox_disable_data($entry);

		$timestamp = time();

		if ($rs == 0) {

			$sql = "update mail_users set status='disabled' where mail_id = $mbox_id;";

		} else {

			($sub_name, $msg) = split(/$main::el_sep/, pop_el(\@main::el));

			$msg =~ s/\'/\\\'/g;

			$sql = "update mail_users set status='$sub_name | $msg' where mail_id = $mbox_id;";

		}

		($rs, $rdata) = doSQL($sql);
		return $rs if ($rs != 0);

	}

	# We'll wait a little, to build full backup history;

	sleep(1);

	push_el(\@main::el, 'mbox_mngr_engine()', 'Ending...');
	return 0;

}

my $rs = undef;

$rs = mbox_mngr_start_up();

if ($rs != 0) {

	dump_el(\@main::el, $main::ispcp_mbox_mngr_el);

	mbox_mngr_shut_down();

	exit 1;

}

$rs = mbox_mngr_engine();

if ($rs != 0) {

	dump_el(\@main::el, $main::ispcp_mbox_mngr_el);

	mbox_mngr_shut_down();

	exit 1;

}

$rs = mbox_mngr_shut_down();

if ($rs != 0) {

	dump_el(\@main::el, $main::ispcp_mbox_mngr_el);

	exit 1;

}

exit 0;
