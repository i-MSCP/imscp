#!/usr/bin/perl

# ispCP ω (OMEGA) a Virtual Hosting Control Panel
# Copyright (C) 2006-2010 by isp Control Panel - http://ispcp.net
#
# Version: $Id$
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
# License for the specific language governing rights and limitations
# under the License.
#
# The Original Code is "ispCP ω (OMEGA) a Virtual Hosting Control Panel".
#
# The Initial Developer of the Original Code is ispCP Team.
# Portions created by Initial Developer are Copyright (C) 2006-2010 by
# isp Control Panel. All Rights Reserved.
#
# The ispCP ω Home Page is:
#
#    http://isp-control.net
#

#
# Special note for the Dev Team:
#
# It is necessary for the error recovery and update procedure that the scripts
# are idempotent. This means if one run of the script is successful and it is
# called again, it does not demolish the installation or cause any harm on it.
# Just ensures that everything is the way it should be.
# If a call failed or was aborted half way for some reason, the next call should
# merely do the tasks left undone the first time (if any) and exit with a
# success status if everything is okay.
#
# This is an important point since the successful execution of the script should
# allow the user to generate configuration files related to services that were
# not activated during the prior pass (e.g. AWStats).
#

use strict;
use warnings;

# FIXME: Check if it ok for all dist
use Term::ReadKey;

# Todo Add this package to package files
# (i.e. Debian: libfile-mimeinfo-perl)
use File::MimeInfo::Magic;

use Term::ANSIColor qw(:constants colored);
$Term::ANSIColor::AUTORESET = 1;

use FindBin;
use lib "$FindBin::Bin/..";

require 'ispcp_common_code.pl';
require 'ispcp-setup-methods.pl';

# User entries
%main::ua = ();

# Re-assigned here to avoid 'used only once: possible typo warning'
$main::cfg_re = '^[ \t]*([\_A-Za-z0-9]+) *= *([^\n\r]*)[\n\r]';
@main::db_connect = ();
$main::db_host = undef;
$main::db_user = undef;
$main::db_name = undef;

#
## Subroutines - Begin
#

# Start the update process
sub update_startup {

	push_el(\@main::el, 'update_startup()', 'Starting...');

	# FIXME: PM Joxi
	if(-e '/tmp/ispcp-backup-all.lock') {
		exit_msg('Backup engine is currently running. Aborting...');
	}

	push_el(\@main::el, 'update_startup()', 'Ending...');

	0;
}

# Performs all update tasks
sub update_engine {

	push_el(\@main::el, 'update_engine()', 'Starting...');

	my ($rs, $print) = (undef, '');

	# User dialog
	user_dialog();

	system('clear');

	# Stopping services
	$print = 'Stopping Services:';
	print STDOUT "\n\t" . $print;
	$rs = stop_services();
	exit_msg(str_to_right('[failed]', length($print)+11), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print)+11);

	# Starting pre-installation script if exists
	if(-e "$main::cfg{'ROOT_DIR'}/engine/setup/preinst") {

		print STDOUT "\n\tStarting pre-installation / update script:";
		$rs = preinst('update');
		exit_msg('Failed!', $rs) if($rs != 0);

	}

	#
	## IspCP main configuration file - Begin
	#

	print STDOUT BOLD "\n\tispCP main configuration file\n";

	# Loading old ispCP configuration file
	$print = ' Loading old ispCP configuration file:';
	print STDOUT "\t" . $print;
	$rs = load_old_ispcp_cfg();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	# Update ispCP configuration file
	$print = ' Update ispCP configuration file:';
	print STDOUT "\t" . $print;
	$rs = update_ispcp_cfg();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));
	
	
	# Check configuration file
	$print = ' Check ispCP configuration file:';
	print STDOUT "\t" . $print;
	$rs = check_ispcp_cfg_file();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0 && $rs != -5);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print)) if($rs != -5);

	#
	## IspCP main configuration file - End
	#

	#
	## IspCP database - Begin
	#

	print STDOUT BOLD "\n\tispCP database\n";

	# Update ispCP database schema
	$print = ' Update ispCP database schema:';
	print STDOUT "\t" . $print;
	$rs = update_database_schema();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	#
	## IspCP database - End
	#

	#
	## IspCP Services configuration files - Begin
	#

	# Rebuilding all services configuration files
	print STDOUT BOLD "\n\tRebuilding all service configuration files\n";
	rebuild_services_cfg();

	#
	## IspCP Services configuration files - End
	#

	#
	## IspCP gui configuration files - Begin
	#

	# Rebuilding all GUI related configuration files
	print STDOUT BOLD "\n\tRebuilding all GUI configuration files\n ";
	rebuild_gui_cfg();

	#
	## IspCP gui configuration files - End
	#

	#
	## IspCP customers configuration files - Begin
	#

	# Rebuilding all customers configuration files
	print STDOUT BOLD "\n\tRebuilding all customer configuration files";
	$print = ' Please wait, this may take some time:';
	print STDOUT "\n\t" . $print;
	$rs = rebuild_customers_cfg();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	#
	## IspCP customers configuration files - End
	#

	#
	## Additional tasks - Begin
	#

	print STDOUT BOLD "\n\tAdditional tasks\n";
	$rs = additional_tasks();

	#
	## Additional tasks - End
	#

	#
	## IspCP files permissions - Begin
	#

	# Set engine and GUI permissions
	print STDOUT BOLD "\n\tSet engine and GUI permissions\n";
	set_permissions();

	#
	## IspCP files permissions - End
	#

	# Starting services
	$print = 'Starting services:';
	print STDOUT "\n\t" . $print;
	$rs = start_services();
	exit_msg(str_to_right('[failed]', length($print)+11), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print) + 11);

	# Starting Post installation script if it exists
	if(-e "$main::cfg{'ROOT_DIR'}/engine/setup/postinst") {

	print STDOUT "\n\tStarting post installation / update script:\n\n";
	$rs = postinst('update');
	exit_msg('Failed!', $rs) if($rs != 0);

	}

	push_el(\@main::el, 'update_engine()', 'Ending...');

	0;
}

# Shutdown update process
sub update_shutdown {

	push_el(\@main::el, 'update_shutdown()', 'Starting...');

	# Removes all's empty files in ispCP configuration directories
	my $rs = setup_cleanup();
	return $rs if($rs != 0);

	my $shut_down_message = colored(
		['bold underline'],
		"\n\n\tCongratulations, you updated ispCP " .
		"'$main::cfg{'Version'}' successfully!\n\n"
	);

	my $login_message =
		"\tType http://$main::cfg{'BASE_SERVER_VHOST'} into your browser to " .
		"log in\n\tto your panel.\n\n";

	print STDOUT $shut_down_message, $login_message;

	push_el(\@main::el, 'update_shutdown()', 'Ending...');

	0;
}

# User dialog
sub user_dialog {

	push_el(\@main::el, 'user_dialog()', 'Starting...');

	welcome_note();

	warn_msg();

	push_el(\@main::el, 'user_dialog()', 'Ending...');

	0;
}

# Welcome note
sub welcome_note {

	push_el(\@main::el, 'welcome_note()', 'Starting...');

	my $rdata = undef;

	# Clear screen
	system('clear');

	my $welcome = colored(['bold underline'],
		"\n\tWelcome to ispCP '$main::cfg{'Version'}' Update Dialog.\n\n");

	my $welcome_message =
		"\tThis program will update your current ispCP OMEGA installation on " .
		"this\n\tserver.\n\tPlease make sure you did a backup of all your " .
		"server data.\n\n";

	my $welcome_note = colored(['bold'], "\tNOTE:") .
		" During the migration process some or all services might require to\n".
		"\tbe shut down.\n\n";

	my $welcome_warning = colored(['bold yellow'], "\tWARNING:") .
		" Only services that are not marked with 'NO' in your ispcp.conf\n".
		"\tconfiguration file will be processed by this program.\n\n";

	print STDOUT $welcome, $welcome_message, $welcome_note, $welcome_warning;

	do {
		print STDOUT "\tDo you want to continue [Y/n]: ";
		chomp($rdata = readline \*STDIN);

	} while($rdata !~ /^(|y|n)$/i);

	exit 0 if($rdata =~ /^n$/i);

	push_el(\@main::el, 'welcome_note()', 'Ending...');

	0;
}

# Warn message
sub warn_msg {

	push_el(\@main::el, 'warn_msg()', 'Starting...');

	my $rdata = undef;

	my $warning = colored(['bold blue'], "\n\tNOTICE:") .
		" Make sure you have read and performed all steps from\n".
		"\tdocs/distro/INSTALL document (where distro is your linux " .
		"distribution).\n\n";

	system 'clear';

	print STDOUT $warning;

	do {

		if(defined $rdata && $rdata eq '?')	{
			print STDOUT "\n\tOptions:\n" .
  				"\t\ty : Continue the update\n" .
  				"\t\tn : Abort and exit\n" .
  				"\t\ts : Select specific tasks to perform " .
  				"(Not yet implemented)\n\n";
		}

		print STDOUT "\tDo you want to continue [Y/n/?]: ";

		chomp($rdata = readline \*STDIN);

	} while($rdata !~ /^(|n|y)$/i);

	exit 0 if($rdata =~ /^n$/i);

	push_el(\@main::el, 'warn_msg()', 'Ending...');

	0;
}

# Load old ispCP main configuration file
sub load_old_ispcp_cfg {

	push_el(\@main::el, 'load_old_ispcp_config()', 'Starting...');

	my ($rs, $old_ispcp_cfg_file) = (undef, '/etc/ispcp/ispcp.old.conf');

	if (get_conf($old_ispcp_cfg_file)) {

		do {
			print STDOUT "\tPlease enter path to your ispcp.old.conf " .
				"[/etc/ispcp/ispcp.old.conf]: ";

			chomp($old_ispcp_cfg_file = readline \*STDIN);

		} while (get_conf($old_ispcp_cfg_file));
	}

	$main::ua{'old_cfg_file'} = $old_ispcp_cfg_file;

	push_el(\@main::el, 'load_old_ispcp_config()', 'Ending...');

	0;
}

# Update ispCP main configuration file
sub update_ispcp_cfg {

	push_el(\@main::el, 'update_ispcp_config()', 'Starting...');

	my ($rs, $rdata) = (undef, undef);

	# Loading old ispCP configuration file as a string
	($rs, $rdata) = get_file($main::ua{'old_cfg_file'});
	return $rs if($rs != 0);

	# Loading new configuration from /etc/ispcp/ispcp.conf
	$rs = get_conf();
	return $rs if($rs != 0);

	# For each cfg line
	foreach(map{$$_."\n"} \split(/\n/, $rdata))	{

		if(/$main::cfg_re/ && $1 !~ /^BuildDate|Version|CodeName$/) {

			# If the old configuration key still exists in the new file
			# and its value is different from existing
			if(defined($main::cfg{$1}) && $main::cfg{$1} ne $2 ) {

				# We restore old value
				$rs = set_conf_val($1, $2);
				return $rs if ($rs != 0);
			}
		}
	}

	# Store the updated configuration in /etc/ispcp/ispcp.conf and reload it
	# at the same time
	$rs = store_conf();
	return $rs if ($rs != 0);

	push_el(\@main::el, 'update_ispcp_config()', 'Ending...');

	0;
}

# Check for empty values in configuration file
#
# Only the configuration settings listed in the
# exception list can be empty.
#
# See main::cfg_recovery_process() for more
# information about the recovery procedure
#
sub check_ispcp_cfg_file {

	push_el(\@main::el, 'check_ispcp_cfg_file()', 'Starting...');

	my %exception = map {$_ => undef} qw(
		DATABASE_PASSWORD
		SECONDARY_DNS
		ISPCP_SUPPORT_SYSTEM_TARGET
		MYSQL_PREFIX_TYPE
		OTHER_ROOTKIT_LOG
	);

	my $empty_settings = [];

	foreach(sort keys %main::cfg) {
		if($main::cfg{$_} eq '' && !exists $exception{$_}) {
			push @$empty_settings, $_;
		}
	}

	# We switch to recovery process if one or more
	# settings were an empty value
	if (scalar @$empty_settings) {
		my  $rs = cfg_recovery_process($empty_settings);
		return $rs;
	}

	push_el(\@main::el, 'check_ispcp_cfg_file()', 'Ending...');

	0;
}

# Recovery process for ispCP cfg settings who's have empty value
#
# If a specific dialog function exists for handling the configuration
# setting, it is called. Otherwise, a error message is returned
# to the user and the program ends. If a configuration setting is
# not supported by the recovery process, those who were already
# corrected are registered before the program ends
#
# The user can also choose not to run the recovery process. In this
# case, the update process ends.
#
# @param ref to an array of ispCP setting names
#
sub cfg_recovery_process {

	push_el(\@main::el, 'check_ispcp_cfg_file()', 'Starting...');

	# Ref to an array of settings names that have a unallowed empty value
	my $settings = shift;

	my ($rs, $msg, $rdata, $warn_msg) = (undef, undef, undef, undef);

	# Map each setting to appropriate dialog subroutine and mainua key name
	# TODO: Add a trigger to check database connection if related setting values
	# are changed && add a subroutine for the 'BASE_SERVER_VHOST' to prevent
	# errors  if a dns file doesn't exist for him
	my $recovery_dispatcher = {
		DEFAULT_ADMIN_ADDRESS => [\&ask_admin_email, 'admin_email'],
		SERVER_HOSTNAME => [\&ask_hostname, 'hostname'],
		BASE_SERVER_IP => [\&ask_eth, 'eth_ip'],
		BASE_SERVER_VHOST => [\&ask_vhost, 'admin_vhost'],
		DATABASE_HOST => [\&ask_db_host, 'db_host'],
		DATABASE_NAME => [\&ask_db_name, 'db_name'],
		DATABASE_USER => [\&ask_db_user, 'db_user'],
		PHP_FASTCGI => [\&ask_fastcgi, 'php_fastcgi']
	};

	# If several parameters are set to an empty value, we ensure
	# that the user has installed ispCP by asking the question
	if(scalar(@$settings) >= 2) {

		print colored(['bold yellow'], "\n\n\tWARNING:").
			" Your ispCP configuration file has several settings set\n" .
			"\tto an empty value !\n";

		do {
			print STDOUT "\n\tAre you sure you have installed ispCP ? [Y/n]: ";
			chomp($rdata = readline \*STDIN);
		} while($rdata !~ /^(|y|n)$/i);

		$msg = colored(['bold blue'], "\n\tNOTICE:") .
			" The program will end now !\n" .
			"\tPlease, run '$main::cfg{'ROOT_DIR'}/engine/setup/ispcp-setup' instead !\n";

		($rdata !~ /^n$/i) or exit_msg($msg);
	}

	print STDOUT colored(['bold yellow'], "\n\n\tWARNING:") .
		" Your ispCP configuration file is not valid!\n" .
		"\tThe program will switch to recovery mode now...\n";

	do {
		print STDOUT "\n\tDo you want to continue [Y/n]: ";
		chomp($rdata = readline \*STDIN);
	} while($rdata !~ /^(|y|n)$/i);

	# Exit with a notice message if the user choose
	# to abort the recovery process
	($rdata !~ /^n$/i) or exit_msg(
		colored(['bold blue'], "\n\tNOTICE:") .
		" The recovery process was aborted by user...\n"
	);

	# For each setting, calls the dialog subroutine if it is available,
	# OTHERWISE saves the values already changed and stops the program
	# with an specific message.
	foreach(@$settings) {

		# If the recovery process can handle the setting
		if (exists $recovery_dispatcher->{$_}) {

			# Call related dialog subroutine
			do {
				($rs, $warn_msg) = &{$recovery_dispatcher->{$_}[0]}();
				print STDERR $warn_msg if(defined($warn_msg) && $warn_msg ne '');
			} while($rs != 0);

			# Set the new configuration value
			$rs = set_conf_val($_, $main::ua{$recovery_dispatcher->{$_}[1]});
			return $rs if ($rs != 0);

			# Otherwise, the program will end here with an error message
		} else {

			# Store already changed values in ispcp.conf
			$rs = store_conf();
			return $rs if($rs != 0);
			
			# Updates the reference file if needed
			if($main::cfg_file ne $main::ua{'old_cfg_file'}) {
				$rs = sys_command_rs("$main::cfg{CMD_CP} -f $main::cfg_file $main::ua{'old_cfg_file'} ");
				return $rs if($rs != 0);
			}

			$msg = colored(['bold blue'], "\n\tNOTICE: ") .
				"The setting '$_' can't be handle by\n" .
				"\tthe recovery process!\n\n" .
				"\tPlease, set it manually in your $main::ua{'old_cfg_file'} and\n" .
				"\tre-run this script.\n\n" .
				"\tThe program will end now !\n";

			exit_msg($msg);
		}
	}

	# Store new configuration settings values and reload it
	$rs = store_conf();
	return $rs if($rs != 0);

	# Updates the reference file if needed
	if($main::cfg_file ne $main::ua{'old_cfg_file'}) {
		$rs = sys_command_rs("$main::cfg{CMD_CP} -f $main::cfg_file $main::ua{'old_cfg_file'} ");
		return $rs if($rs != 0);
	}

	print STDOUT colored(['bold blue'], "\n\tNOTICE:") .
		" The recovery process was end successfully!\n" .
		"\tThe update process will continue normally now...\n\n";

	push_el(\@main::el, 'check_ispcp_cfg_file()', 'Ending...');

	-5;
}

# Update ispCP database schema
sub update_database_schema {

	push_el(\@main::el, 'update_database_schema()', 'Starting...');

	my ($rs, $cmd, $php, $rdata) = (undef, undef, undef, undef);

	# File preparation - Begin

	($rs, $rdata) = get_file("$main::cfg{'ROOT_DIR'}/engine/setup/updDB.php");
	return $rs if($rs != 0);

	if($rdata =~ s/{GUI_ROOT_DIR}/$main::cfg{'GUI_ROOT_DIR'}/) {

		# Saving the modified file
		$rs = save_file(
			"$main::cfg{'ROOT_DIR'}/engine/setup/updDB.php",
			$rdata
		);
		return $rs if($rs != 0);
	}

	# File preparation - End

	$main::db_pwd =~ s/([\'\"])/\\$1/g;

	$cmd = "
		$main::cfg{'CMD_PHP'} $main::cfg{'ROOT_DIR'}/engine/setup/updDB.php " .
		"&>/tmp/ispcp-update-database.log";

	$rs = sys_command_rs($cmd);
	return $rs if($rs !=0);

	push_el(\@main::el, 'update_database_schema()', 'Ending...');

	0;
}

# Rebuilding all services configuration files
sub rebuild_services_cfg {

	push_el(\@main::el, 'rebuild_services_config()', 'Starting...');

	my ($rs, $print) = (undef, '');

	$print = ' ispCP Crontab file:';
	print STDOUT "\t" . $print;
	$rs = setup_crontab();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP BIND main configuration file:';
	print STDOUT "\t" . $print;
	$rs = setup_named();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP PHP (fastCGI modules configuration):';
	print STDOUT "\t" . $print;
	$rs = setup_php();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP Apache main vhost file:';
	print STDOUT "\t" . $print;
	$rs = setup_httpd_main_vhost();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP Apache AWStats vhost file:';
	print STDOUT "\t" . $print;
	$rs = setup_awstats_vhost();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP Postfix configuration files:';
	print STDOUT "\t" . $print;
	$rs = setup_mta();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP Courier-Authentication:';
	print STDOUT "\t" . $print;
	$rs = setup_po();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP ProFTPd configuration file:';
	print STDOUT "\t" . $print;
	$rs = setup_ftpd();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP init scripts:';
	print STDOUT "\t" . $print;
	$rs = setup_ispcp_daemon_network();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	push_el(\@main::el, 'rebuild_services_config()', 'Ending...');

	0;
}

# Rebuilding all gui related configuration files
sub rebuild_gui_cfg {

	push_el(\@main::el, 'rebuild_gui_cfg()', 'Starting...');

	my ($rs, $print) = (undef, "");

	$print = ' ispCP GUI BIND configuration:';
	print STDOUT "\t" . $print;
	$rs = setup_gui_named();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP GUI fastCGI/PHP configuration:';
	print STDOUT "\t" . $print;
	$rs = setup_gui_php();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP GUI vhost file:';
	print STDOUT "\t" . $print;
	$rs = setup_gui_httpd();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	$print = ' ispCP PMA configuration file:';
	print STDOUT "\t" . $print;
	$rs = setup_gui_pma();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	push_el(\@main::el, 'rebuild_gui_cfg()', 'Ending...');

	0;
}

# Rebuilding all customers configuration files
sub rebuild_customers_cfg {

	push_el(\@main::el, 'rebuild_customers_cfg()', 'Starting...');

	my ($rs, $rdata) = (undef, undef);

	# First, we reset db connection
	$main::db = undef;

	# Sets the dsn
	@main::db_connect = (
		"DBI:mysql:$main::db_name:$main::db_host",
		$main::db_user,
		$main::db_pwd
	);

	my $tables = {
		domain => 'domain_status',
		domain_aliasses => 'alias_status',
		subdomain => 'subdomain_status',
		subdomain_alias => 'subdomain_alias_status',
		mail_users => 'status',
		htaccess => 'status',
		htaccess_groups => 'status',
		htaccess_users => 'status'
	};

	# Set status as 'change'
	while (my ($table, $field) = each %$tables) {
		($rs, $rdata) = doSQL(
			"
				UPDATE
					$table
				SET
					$field = 'change'
				WHERE
					($field = 'ok' OR $field = 'disabled') 
				;
			"
		);
		return $rs if ($rs != 0);
	}

	$main::db = undef;

	$rs = sys_command_rs(
		"perl $main::cfg{'ROOT_DIR'}/engine/ispcp-rqst-mngr " .
		"&>/tmp/ispcp-update-customers.log");
	return $rs if ($rs != 0);

	push_el(\@main::el, 'rebuild_customers_cfg()', 'Ending...');

	0;
}

# Run all update additional task such a rkhunter configuration
sub additional_tasks() {

	push_el(\@main::el, 'additional_tasks()', 'Starting...');

	my ($rs, $print) = (undef, '');

	$print = ' Rkhunter configuration:';
	print STDOUT "\t" . $print;
	$rs = setup_rkhunter();
	exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);
	print STDOUT BOLD GREEN str_to_right('[done]', length($print));

	push_el(\@main::el, 'additional_tasks()', 'Ending...');

	0;
}

# Set engine and gui permissions
# TODO: Move it into ispcp-setup-methods.pl and call it into ispcp-setup
sub set_permissions {

	push_el(\@main::el, 'set_permissions()', 'Starting...');

	my ($rs, $cmd, $print) = (undef, undef, '');

	foreach(qw/engine gui/) {

		$print = " Set $_ permissions:";
		print STDOUT "\t" . $print ;

		$cmd =
			"$main::cfg{'CMD_SHELL'} " .
			"$main::cfg{'ROOT_DIR'}/engine/setup/set-$_-permissions.sh " .
			"&>/tmp/ispcp-update-permissions.log";

		$rs = sys_command_rs($cmd);
		exit_msg(str_to_right('[failed]', length($print)), $rs) if($rs != 0);

		print STDOUT BOLD GREEN str_to_right('[done]', length($print));
	}

	push_el(\@main::el, 'set_permissions()', 'Ending...');

	0;
}

#
## Subroutines - End
#

#
## Main
#

update_startup();
update_engine();
update_shutdown();

exit 0;
